# 使用例

コード内でデータ権限を使用する場合、現在は動的な有効化と無効化をサポートする複数の方法があります。
以下に、いくつかの一般的な開発ケースを挙げます。

## モデル全体に対するデータ権限制御

デフォルトの `User` モデルを例に、`User` モデルにデータ権限制御を適用する場合を想定します。

`User` モデルで `DataScopes` trait を使用することで、データ権限スコープを有効にできます。

```php
use App\Library\DataPermission\Scope\DataScopes;

class User {
    // データ権限スコープを使用
    use DataScopes;

    // その他のコード...
}
```

これにより、`User` モデルに対するすべてのクエリに自動的にデータ権限制御が適用されます。

## 特定のコードブロックに対するデータ権限制御

Hyperf AOP の特性を活用して、クラスまたはクラスメソッドに [DataScope](https://github.com/mineadmin/MineAdmin/blob/master-department/app/Library/DataPermission/Attribute/DataScope.php) アノテーションを使用することで、指定したコードブロックにデータ権限制御を適用できます。

組み込みのユーザーモジュールの[ページネーションリスト](https://github.com/mineadmin/MineAdmin/blob/master-department/app/Service/Permission/UserService.php#L93~L100)を例にします：

```php
class UserService
{
    #[DataScope(
        scopeType: ScopeType::CREATED_BY,
        onlyTables: ['user']
    )]
    public function page(array $params, int $page = 1, int $pageSize = 10): array
    {
        return parent::page($params, $page, $pageSize); // TODO: Change the autogenerated stub
    }
}
```

`page` メソッドが呼び出されると、データ権限が自動的にクエリに適用されます。

## 指定したORMクエリに対する権限制御

特定のシナリオでは、より細かい権限分離が必要になる場合があります。そのような場合、`Factory::make()->build()` メソッドを使用して指定したクエリに制限をかけることができます。

```php
use App\Library\DataPermission\Factory;
use App\Model\Permission\User;
use App\Model\Permission\Wallet;

class DemoService {
    public function test(User $user): void{
        $walletQuery = Wallet::query();
        // WalletQueryに対して個別にデータ分離を適用
        Factory::make()->build($user,$walletQuery->getQuery());
    }
}
```

## 他のフィールドを分離条件として指定

業務テーブルでデフォルトの `created_by` や `dept_id` フィールド名と異なる場合や、複雑な結合クエリでテーブル名が `table as xxxx` のように変更されている場合、新しい分離フィールドを指定する必要があります。以下に、異なる使用方法で新しいフィールドを指定する方法の例を示します。

### アノテーションを使用してメソッドを分離する場合

組み込みの `DataScope` アノテーションには、新しいフィールドを簡単に指定できるパラメータがあります。

```php
<?php

declare(strict_types=1);
/**
 * This file is part of MineAdmin.
 *
 * @link     https://www.mineadmin.com
 * @document https://doc.mineadmin.com
 * @contact  root@imoi.cn
 * @license  https://github.com/mineadmin/MineAdmin/blob/master/LICENSE
 */

namespace App\Library\DataPermission\Attribute;

use App\Library\DataPermission\ScopeType;
use Hyperf\Di\Annotation\AbstractAnnotation;

#[\Attribute(\Attribute::TARGET_CLASS | \Attribute::TARGET_METHOD)]
final class DataScope extends AbstractAnnotation
{
    public function __construct(
        // 部門フィールド名を指定
        private readonly string $deptColumn = 'dept_id',
        // 作成者フィールド名を指定
        private readonly string $createdByColumn = 'created_by',
        // 分離方式
        private readonly ScopeType $scopeType = ScopeType::DEPT_CREATED_BY,
        // 指定したテーブルのみを分離。空の場合はすべて分離
        private readonly ?array $onlyTables = null
    ) {}

    public function getOnlyTables(): ?array
    {
        return $this->onlyTables;
    }

    public function getDeptColumn(): string
    {
        return $this->deptColumn;
    }

    public function getCreatedByColumn(): string
    {
        return $this->createdByColumn;
    }

    public function getScopeType(): ScopeType
    {
        return $this->scopeType;
    }
}
```

### `Factory::make()->build` を手動で使用する場合

`Factory` インスタンスを手動で呼び出して条件を組み立てる場合は、`App\Library\DataPermission\Context` を使用して設定する必要があります。

```php
use App\Library\DataPermission\Context as Ctx;
use App\Library\DataPermission\Factory;

// sssテーブルのみをデータ分離
Ctx::setOnlyTables(['sss']);
// 部門フィールド名を設定
Ctx::setDeptColumn('department_id');
// 作成者フィールド名を設定
Ctx::setCreatedByColumn('creator');
// 分離方式を設定
Ctx::setScopeType(ScopeType::DEPT_CREATED_BY);

$query = XXXModel::query();

Factory::make()->build($user,$query->getQuery());
```

::: warning

注意点として、どの使用方法であっても、新しいコルーチンを開始する場合は、再度設定を行う必要があります。

:::